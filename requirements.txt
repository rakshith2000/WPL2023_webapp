import ttkbootstrap as ttkb
from ttkbootstrap.constants import *
from ttkbootstrap.style import Style
import tkinter as tk
import psutil, wmi, socket, platform, subprocess, paramiko, re
from datetime import datetime
import threading
from queue import Queue

class DiskProgressBar(tk.Frame):
    def __init__(self, master, server_type, conn, path="C:", label="Disk", fg_color="#28a745", **kwargs):
        super().__init__(master, **kwargs)
        self.path = path
        self.label = label
        self.conn = conn
        self.server_type = server_type
        self.fg_color = fg_color
        self.configure(bg="#FFF0F5")

        self.canvas = tk.Canvas(self, width=600, height=100, bg="#FFF0F5", highlightthickness=0)
        self.canvas.pack(pady=0)
        self.update_disk_usage()

    def update_disk_usage(self):
        if self.server_type == "Windows":
            disk = next((disk for disk in self.conn if disk.DeviceID == self.path), None)
            self.total_gb = round(int(disk.Size) / (1024 ** 3), 2)
            self.free_gb = round(int(disk.FreeSpace) / (1024 ** 3), 2)
            self.used_gb = round(self.total_gb - self.free_gb, 2)
            self.used_per = round((self.used_gb / self.total_gb) * 100, 2)
        else:
            self.total_gb = self.conn['total_gb']
            self.used_gb = self.conn['used_gb']
            self.used_per = round((self.used_gb / self.total_gb) * 100, 2)

        if self.used_per >= 95.00:
            self.fg_color = "#dc3545"
        elif self.used_per >= 85.00:
            self.fg_color = "#ffc107"
        else:
            self.fg_color = "#28a745"

        self.draw_progress_bar()

    def draw_progress_bar(self):
        self.canvas.delete("all")
        bar_width = 500
        bar_height = 20
        bar_x = 20
        bar_y = 30

        self.canvas.create_rectangle(
            bar_x, bar_y,
            bar_x + bar_width, bar_y + bar_height,
            fill="#E0E0E0", outline=""
        )

        fill_width = (self.used_per / 100) * bar_width
        self.canvas.create_rectangle(
            bar_x, bar_y,
            bar_x + fill_width, bar_y + bar_height,
            fill=self.fg_color, outline=""
        )

        self.canvas.create_text(
            30, 10,
            text=f"{self.label} Usage ({self.path})",
            font=("Helvetica", 10, "bold"),
            fill="#333",
            anchor="w"
        )

        self.canvas.create_text(
            250, 60,
            text=f"{self.used_per:.1f}% used ({self.used_gb:.1f} GB / {self.total_gb:.1f} GB)",
            font=("Helvetica", 10, "bold"),
            fill="#666"
        )

        self.canvas.create_text(
            bar_x, bar_y + bar_height + 10,
            text="0 GB",
            font=("Helvetica", 10, "bold"),
            fill="#444",
            anchor="w"
        )

        self.canvas.create_text(
            bar_x + bar_width, bar_y + bar_height + 10,
            text=f"{self.total_gb:.0f} GB",
            font=("Helvetica", 10, "bold"),
            fill="#444",
            anchor="e"
        )

class BaseMeter(tk.Frame):
    def __init__(self, master, value, per_value, max_value, unit, label, sublabel, fg_color, **kwargs):
        super().__init__(master, **kwargs)
        self.value = value
        self.per_value = per_value
        self.max_value = max_value
        self.unit = unit
        self.label = label
        self.sublabel = sublabel
        self.fg_color = fg_color
        self.outer_radius = 90
        self.inner_radius = 70
        self.center_x = 120
        self.center_y = 110
        self.configure(bg="#FFF0F5")
        self.canvas = tk.Canvas(self, width=240, height=150, bg="#FFF0F5", highlightthickness=0)
        self.canvas.pack(pady=0)

        self.update_meter_color()
        self.draw_meter()
        self.draw_text()
        self.draw_labels()

    def update_meter_color(self):
        if self.per_value >= 95.00:
            self.fg_color = "#dc3545"
        elif self.per_value >= 85.00:
            self.fg_color = "#ffc107"
        else:
            self.fg_color = "#28a745"

    def draw_meter(self):
        percent = min(self.value / self.max_value, 1.0)
        extent_angle = -percent * 180

        self.canvas.create_arc(
            self.center_x - self.outer_radius, self.center_y - self.outer_radius,
            self.center_x + self.outer_radius, self.center_y + self.outer_radius,
            start=180, extent=-180, fill="#E0E0E0", outline=""
        )

        self.canvas.create_arc(
            self.center_x - self.outer_radius, self.center_y - self.outer_radius,
            self.center_x + self.outer_radius, self.center_y + self.outer_radius,
            start=180, extent=extent_angle, fill=self.fg_color, outline=""
        )

        self.canvas.create_arc(
            self.center_x - self.inner_radius, self.center_y - self.inner_radius,
            self.center_x + self.inner_radius, self.center_y + self.inner_radius,
            start=180, extent=-180, fill="white", outline="white"
        )

    def draw_labels(self):
        label_radius = self.outer_radius
        y_offset = self.center_y + 10

        self.canvas.create_text(
            self.center_x - label_radius, y_offset,
            text=f"0 {self.unit}", font=("Helvetica", 10, "bold"),
            fill="#444", anchor="w"
        )

        self.canvas.create_text(
            self.center_x + label_radius, y_offset,
            text=f"{self.max_value:.0f} {self.unit}", font=("Helvetica", 10, "bold"),
            fill="#444", anchor="e"
        )

    def draw_text(self):
        pass

class CPUSemiCircularMeter(BaseMeter):
    def __init__(self, master, conn, server_type, **kwargs):
        if server_type == "Windows":
            try:
                cpu_percent = 0 if conn.LoadPercentage == None else conn.LoadPercentage
            except Exception as e:
                cpu_percent = 0
        else:
            try:
                cpu_percent = 0 if conn['LoadPercentage'] == None else conn['LoadPercentage']
            except Exception as e:
                cpu_percent = 0

        super().__init__(
            master, value=cpu_percent, per_value=cpu_percent, 
            max_value=100, unit="%", label="CPU Usage",
            sublabel="", fg_color="#007bff", **kwargs
        )

    def draw_text(self):
        self.canvas.create_text(
            self.center_x, 70,
            text=f"{self.value:.1f}%", 
            font=("Helvetica", 12, "bold"), 
            fill="#333"
        )
        self.canvas.create_text(
            self.center_x, 95,
            text=self.label, 
            font=("Helvetica", 10, "bold"), 
            fill="#666"
        )

class StorageSemiCircularMeter(BaseMeter):
    def __init__(self, master, label, conn, server_type, fg_color="#28a745", **kwargs):
        if server_type == "Windows":
            try:
                ram = conn
                used_gb = (int(ram.TotalVisibleMemorySize) - int(ram.FreePhysicalMemory)) / (1024 ** 2)
                total_gb = int(ram.TotalVisibleMemorySize) / (1024 ** 2)
                used_per = round((used_gb/total_gb) * 100, 2)
            except Exception as e:
                used_gb = 0.00
                total_gb = 0.00
                used_per = 0.00
        else:
            try:
                ram = conn
                used_gb = ram['UsedMemory']
                total_gb = ram['TotalVisibleMemorySize']
                used_per = round((used_gb/total_gb) * 100, 2)
            except Exception as e:
                used_gb = 0.00
                total_gb = 0.00
                used_per = 0.00

        display_value = used_gb
        sublabel = f"{used_gb:.1f} GB {label} Used"

        super().__init__(
            master, value=display_value, per_value=used_per, 
            max_value=total_gb, unit="GB", label=label, 
            sublabel=sublabel, fg_color=fg_color, **kwargs
        )

    def draw_text(self):
        self.canvas.create_text(
            self.center_x, 70,
            text=f"{self.per_value:.1f}%", 
            font=("Helvetica", 12, "bold"), 
            fill="#333"
        )
        self.canvas.create_text(
            self.center_x, 95,
            text=self.sublabel, 
            font=("Helvetica", 10, "bold"), 
            fill="#666"
        )

class SystemHealthCheckDashboard(ttkb.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.pack(fill="both", expand=True)
        self.message_queue = Queue()
        
        # Server credentials
        user1 = "kosv1106"
        password1 = "c3RM21nvPx2&%32fsp93v"
        user2 = "kosv1388"
        password2 = "M7!k28p&c30tyBt1"

        self.server_credentials = {
            "USWIW1489": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1490": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1492": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1530": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1531": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1533": {"type": "Windows", "user": user1, "password": password1},
            "USWIW714": {"type": "Windows", "user": user1, "password": password1},
            "USWIW715": {"type": "Windows", "user": user1, "password": password1},
            "USWIW716": {"type": "Windows", "user": user1, "password": password1},
            "USWIX733": {"type": "Linux", "user": user2, "password": password2},
        }

        self.columnconfigure(0, weight=0)
        self.columnconfigure(1, weight=1)
        self.rowconfigure(0, weight=0)
        self.rowconfigure(1, weight=1)

        self.create_header()
        self.create_left_pane()
        self.create_main_area()

        self.current_server = None
        self.server_type = None
        self.wmi_conn = None
        self.os_info = None
        self.processor_info = None
        self.disks_info = None
        self.computer_system_info = None

    def create_header(self):
        header_frame = ttkb.Frame(self, padding=10, bootstyle=PRIMARY)
        header_frame.grid(row=0, column=0, columnspan=2, sticky="nsew")

        header_lbl = ttkb.Label(
            master=header_frame,
            text="System Healthcheck Dashboard",
            bootstyle=(PRIMARY, INVERSE),
            font=("Helvetica", 18, "bold"),
            anchor='center'
        )
        header_lbl.pack(fill="x", expand=True)

    def create_left_pane(self):
        style = ttkb.Style()
        style.configure('Overview.TButton', font=('Calibri', 14, 'bold'))
        style.configure('Get.TButton', font=('Microsoft Sans Serif', 10, 'bold'), 
                      foreground='white', background='#28a745', bordercolor='#28a745', 
                      darkcolor='#28a745', lightcolor='#28a745', relief='raised', 
                      anchor='center')
        style.configure('custom.TLabelframe', bordercolor='#6c757d', 
                       background=style.colors.light)
        style.configure('custom.TLabelframe.Label',
                      font=('Calibri', 14, 'bold'),
                      foreground='#343a40',
                      padding=10, background=style.colors.light)

        left_pane = ttkb.Frame(self, padding=10, bootstyle=LIGHT, width=220)
        left_pane.grid(row=1, column=0, sticky="ns")
        left_pane.grid_propagate(False)

        overview_btn = ttkb.Button(
            left_pane,
            text="Overview",
            bootstyle="success",
            style='Overview.TButton',
        )
        overview_btn.pack(fill="x", pady=(0, 20))

        separator = ttkb.Separator(left_pane, bootstyle=SECONDARY)
        separator.pack(fill="x", pady=(0, 20))

        server_frame = ttkb.LabelFrame(
            left_pane,
            text="Select Server",
            bootstyle="info",
            style='custom.TLabelframe',
            labelanchor="nw"
        )
        server_frame.pack(fill="x", pady=(0, 10))

        self.server_var = ttkb.StringVar(value="Select Server")
        server_menu_btn = ttkb.Menubutton(
            server_frame,
            textvariable=self.server_var,
            bootstyle="primary-outline",
            width=18
        )
        server_menu_btn.pack(fill="x", padx=5, pady=(10, 10))

        menu = tk.Menu(server_menu_btn, tearoff=1)
        server_menu_btn["menu"] = menu
        menu.delete(0)
        
        menu.add_command(label="Windows Servers", state="disabled", font=("Calibri", 10, "bold"))
        win_servers = [s for s, d in self.server_credentials.items() if d["type"] == "Windows"]
        for server in win_servers:
            menu.add_radiobutton(label=f"    {server}", variable=self.server_var, value=server)

        menu.add_separator()

        menu.add_command(label="Linux Servers", state="disabled", font=("Calibri", 10, "bold"))
        lin_servers = [s for s, d in self.server_credentials.items() if d["type"] == "Linux"]
        for server in lin_servers:
            menu.add_radiobutton(label=f"    {server}", variable=self.server_var, value=server)

        self.get_metrics_btn = ttkb.Button(
            server_frame,
            text="Get Metrics",
            bootstyle="success",
            style="Get.TButton",
            width=15,
            command=self.update_server_metrics
        )
        self.get_metrics_btn.pack(pady=(0, 10))

    def create_main_area(self):
        self.main_area = ttkb.Frame(self, padding=(10, 10, 10, 10))
        self.main_area.grid(row=1, column=1, sticky="nsew")

        self.placeholder = ttkb.Label(
            self.main_area,
            text="Please select a server and click 'Get Metrics'",
            font=("Calibri", 16, "bold"),
            bootstyle=SECONDARY
        )
        self.placeholder.pack(expand=True)

    def connect_to_server(self, server, server_type):
        creds = self.server_credentials.get(server, {})
        if server_type == "Windows":
            try:
                return wmi.WMI(server, user=creds.get("user", ""), 
                             password=creds.get("password", ""))
            except Exception as e:
                print(f"WMI Error: {e}")
                return None
        else:
            try:
                client = paramiko.SSHClient()
                client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                client.connect(
                    hostname=server,
                    username=creds.get("user", ""),
                    password=creds.get("password", ""),
                    timeout=10
                )
                return client
            except Exception as e:
                print(f"SSH Error: {e}")
                return None

    def get_server_info(self, server, server_type):
        try:
            if server_type == "Windows":
                self.wmi_conn = self.connect_to_server(server, server_type)
                if not self.wmi_conn:
                    return False

                self.os_info = self.wmi_conn.Win32_OperatingSystem()[0]
                self.processor_info = self.wmi_conn.Win32_Processor()[0]
                self.disks_info = self.wmi_conn.Win32_LogicalDisk()
                self.computer_system_info = self.wmi_conn.Win32_ComputerSystem()[0]
                return True
            else:
                self.ssh_conn = self.connect_to_server(server, server_type)
                if not self.ssh_conn:
                    return False

                commands = """
                    cat /etc/os-release | grep ^NAME=;
                    cat /etc/os-release | grep ^VERSION=;
                    nproc;
                    free -b | awk '/Mem:/{print $2}';
                    uptime -s;
                    top -bn1 | grep 'Cpu(s)' | awk '{print $2 + $4}';
                    free -b | awk '/Mem:/{print $2, $3}';
                    df -B1 / | awk 'NR==2 {print $1,$2,$3,$6}'
                """
                stdin, stdout, stderr = self.ssh_conn.exec_command(commands)
                output = stdout.read().decode().splitlines()

                os_name = output[0].split('=')[1].strip('"')
                os_version = output[1].split('=')[1].strip('"')
                cpu_cores = int(output[2])
                total_ram_bytes = int(output[3])
                uptime_days = (datetime.now() - datetime.strptime(output[4], "%Y-%m-%d %H:%M:%S")).days
                cpu_usage = float(output[5])
                total_ram_gb = round(total_ram_bytes / (1024**3), 2)
                used_ram_gb = round(int(output[6].split()[1]) / (1024**3), 2)
                
                disks = []
                for line in output[7:]:
                    if not line.strip() or 'Filesystem' in line:
                        continue
                    parts = line.split()
                    try:
                        disks.append({
                            "disk": parts[0],
                            "total_gb": round(int(parts[1]) / (1024**3), 2),
                            "used_gb": round(int(parts[2]) / (1024**3), 2),
                            "mount": parts[5]
                        })
                    except (ValueError, IndexError):
                        continue

                self.ssh_conn.close()
                self.os_info = {
                    "Caption": os_name,
                    "BuildNumber": os_version,
                    "TotalVisibleMemorySize": total_ram_gb,
                    "UsedMemory": used_ram_gb,
                    "Uptime": uptime_days
                }
                self.processor_info = {
                    "NumberOfLogicalProcessors": cpu_cores,
                    "LoadPercentage": cpu_usage
                }
                self.computer_system_info = {
                    "TotalPhysicalMemory": total_ram_gb
                }
                self.disks_info = disks
                return True
        except Exception as e:
            print(f"Error getting server info: {e}")
            return False

    def update_server_metrics(self):
        selected_server = self.server_var.get()
        if selected_server == "Select Server":
            return

        self.get_metrics_btn.config(state="disabled")
        self.show_loading(selected_server)

        worker = threading.Thread(
            target=self._fetch_metrics_thread,
            args=(selected_server,),
            daemon=True
        )
        worker.start()
        self.after(100, self.check_queue)

    def _fetch_metrics_thread(self, server):
        try:
            serv_det = self.server_credentials.get(server, {})
            server_type = serv_det.get("type", "")
            
            success = self.get_server_info(server, server_type)
            self.message_queue.put(('result', success, server, server_type))
        except Exception as e:
            self.message_queue.put(('error', str(e)))

    def check_queue(self):
        while not self.message_queue.empty():
            msg = self.message_queue.get()
            
            if msg[0] == 'result':
                success, server, server_type = msg[1:]
                self.handle_metrics_result(success, server, server_type)
            elif msg[0] == 'error':
                self.show_error(msg[1])
        
        self.after(100, self.check_queue)

    def show_loading(self, server):
        if hasattr(self, 'placeholder'):
            self.placeholder.destroy()
        
        if hasattr(self, 'content_frame'):
            self.content_frame.destroy()
        
        self.content_frame = ttkb.Frame(self.main_area)
        self.content_frame.pack(fill="both", expand=True)
        
        self.loading_label = ttkb.Label(
            self.content_frame,
            text=f"Connecting to {server}...",
            font=("Helvetica", 14),
            bootstyle=INFO
        )
        self.loading_label.pack(expand=True)

    def handle_m