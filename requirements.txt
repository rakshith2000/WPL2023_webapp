import tkinter.font as tkfont
from tkinter import Canvas

class SystemHealthCheckDashboard(ttkb.Frame):
    def __init__(self, master):
        # ... (keep all your existing initialization code)
        
        # Add these attributes for the canvas table
        self.table_canvas = None
        self.table_font = None
        self.header_bg = "#000000"
        self.header_fg = "#ffffff"
        self.alt_bg = "#f8f9fa"
        self.cell_height = 30
        self.padding = 10
        
    # Replace your create_treeview_table method with this:
    def create_canvas_table(self):
        """Create a canvas-based table to display server metrics"""
        # Create container frame
        container_frame = ttkb.Frame(self.content_frame)
        container_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Create scrollable canvas
        self.table_canvas = Canvas(container_frame, bg="white", highlightthickness=0)
        scrollbar = ttkb.Scrollbar(container_frame, orient="vertical", command=self.table_canvas.yview)
        self.table_canvas.configure(yscrollcommand=scrollbar.set)
        
        # Pack widgets
        scrollbar.pack(side="right", fill="y")
        self.table_canvas.pack(side="left", fill="both", expand=True)
        
        # Bind mousewheel for scrolling
        self.table_canvas.bind("<Configure>", lambda e: self.draw_table())
        self.table_canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        
        # Initialize font
        self.table_font = tkfont.Font(family="Helvetica", size=10)
        
    def _on_mousewheel(self, event):
        """Handle mousewheel scrolling for the canvas"""
        self.table_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
    def get_column_widths(self, headers, data, available_width):
        """Calculate column widths based on content"""
        max_text_widths = []
        for col_index in range(len(headers)):
            column_texts = [headers[col_index]] + [str(row[col_index]) for row in data]
            max_width = max(self.table_font.measure(text) for text in column_texts) + self.padding
            max_text_widths.append(max_width)

        total_content_width = sum(max_text_widths)
        
        if total_content_width < available_width:
            # Distribute extra width proportionally
            extra = available_width - total_content_width
            max_text_widths = [w + (extra * w / total_content_width) for w in max_text_widths]
            
        return max_text_widths
    
    def get_metric_color(self, value):
        """Determine color based on metric value"""
        if isinstance(value, str):
            if "%" in value:
                try:
                    num = float(value.replace("%", ""))
                    if num >= 95:
                        return "#f44336"  # Red for critical
                    elif num >= 85:
                        return "#ff9800"  # Orange for warning
                    else:
                        return "#4caf50"  # Green for good
                except ValueError:
                    return "black"
            return "black"
        else:
            if value >= 95:
                return "#f44336"
            elif value >= 85:
                return "#ff9800"
            else:
                return "#4caf50"
    
    def draw_table(self):
        """Draw the table with server metrics"""
        if not self.server_details:
            return
            
        # Prepare headers and data
        headers = [
            "Server", "Status", "Type", "Ping", "RDP/SSH", 
            "CPU Usage", "RAM Usage", "C Drive", "D Drive", "Uptime"
        ]
        
        data = []
        for server, metrics in self.server_details.items():
            row = [
                server,
                metrics['status'],
                self.server_credentials[server]['type'],
                "✔" if metrics['ping'] else "✖",
                "✔" if metrics['rdp/ssh'] else "✖",
                f"{metrics['cpu_usage']}%" if metrics['status'] == 'Online' else "N/A",
                f"{metrics['ram_usage']}%" if metrics['status'] == 'Online' else "N/A",
                f"{metrics['C_drive']}%" if metrics['status'] == 'Online' else "N/A",
                f"{metrics['D_drive']}%" if metrics['status'] == 'Online' and 'D_drive' in metrics else "N/A",
                f"{metrics['uptime']} days" if metrics['status'] == 'Online' else "N/A"
            ]
            data.append(row)
        
        # Clear existing items
        self.table_canvas.delete("all")
        
        # Get current canvas width
        canvas_width = self.table_canvas.winfo_width()
        if canvas_width < 100:  # Minimum width
            canvas_width = 1000
            
        # Calculate column widths
        col_widths = self.get_column_widths(headers, data, canvas_width)
        
        # Calculate total height needed
        total_height = (len(data) + 1) * self.cell_height
        
        # Configure canvas scroll region
        self.table_canvas.config(scrollregion=(0, 0, sum(col_widths), total_height))
        
        # Draw headers
        x = 0
        for i, header in enumerate(headers):
            w = col_widths[i]
            self.table_canvas.create_rectangle(
                x, 0, x + w, self.cell_height, 
                fill=self.header_bg, outline="gray"
            )
            self.table_canvas.create_text(
                x + w // 2, self.cell_height // 2, 
                text=header, fill=self.header_fg, 
                font=("Helvetica", 10, "bold")
            )
            x += w
        
        # Draw rows
        for r, row in enumerate(data):
            y0 = (r + 1) * self.cell_height
            y1 = y0 + self.cell_height
            bg_color = self.alt_bg if r % 2 == 0 else "white"
            x = 0
            
            for c, cell in enumerate(row):
                w = col_widths[c]
                self.table_canvas.create_rectangle(
                    x, y0, x + w, y1, 
                    fill=bg_color, outline="gray"
                )
                
                # Determine text color based on metric
                if c >= 5 and c <= 8 and "%" in str(cell):  # Metric columns
                    try:
                        value = float(str(cell).replace("%", ""))
                        color = self.get_metric_color(value)
                    except ValueError:
                        color = "black"
                elif c == 3 or c == 4:  # Ping/RDP columns
                    color = "#4caf50" if cell == "✔" else "#f44336"
                else:
                    color = "black"
                
                self.table_canvas.create_text(
                    x + w // 2, (y0 + y1) // 2, 
                    text=cell, fill=color, 
                    font=("Helvetica", 10)
                )
                x += w
    
    # In your display_metrics method, replace create_treeview_table with:
    def display_metrics(self):
        # Clear previous content
        for widget in self.content_frame.winfo_children():
            widget.destroy()
        
        # Create canvas table
        self.create_canvas_table()
        
        # Create plots
        self.create_plots()
        
        # Update plots with actual data
        self.update_plots_with_metrics()
        
        # Draw the table
        self.draw_table()
