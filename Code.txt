import tkinter as tk
from tkinter import ttk
import ttkbootstrap as ttkb
from ttkbootstrap.constants import *
from ttkbootstrap.dial import Meter
import threading
import queue
import pythonping
import wmi
from datetime import datetime, timedelta
import socket

class ServerHealthDashboard:
    def __init__(self, master):
        self.master = master
        master.title("Windows Server Health Dashboard")
        master.geometry("1400x800")
        
        # Server list - replace with your actual servers
        self.servers = [
            {"name": "Server1", "ip": "192.168.1.1", "rdp_port": 3389, "username": "admin", "password": "password"},
            {"name": "Server2", "ip": "192.168.1.2", "rdp_port": 3389, "username": "admin", "password": "password"},
            # Add more servers...
        ]
        
        self.create_widgets()
        self.update_queue = queue.Queue()
        self.running = True
        self.start_update_thread()
        self.check_after_id = None
        self.schedule_next_check()
        self.server_frames = []
        
    def create_widgets(self):
        # Main container
        main_frame = ttkb.Frame(self.master, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Header
        header = ttkb.Label(
            main_frame, 
            text="Windows Server Health Dashboard", 
            font=('Helvetica', 16, 'bold'),
            bootstyle=PRIMARY
        )
        header.pack(pady=(0, 20))
        
        # Create scrollable dashboard area
        self.canvas = ttkb.Canvas(main_frame)
        self.scrollbar = ttkb.Scrollbar(main_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.scrollable_frame = ttkb.Frame(self.canvas)
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(
                scrollregion=self.canvas.bbox("all")
            )
        )
        
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Create server status cards
        self.create_server_cards()
        
        # Controls frame
        controls_frame = ttkb.Frame(main_frame)
        controls_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.refresh_btn = ttkb.Button(
            controls_frame,
            text="Refresh Now",
            command=self.force_refresh,
            bootstyle=SUCCESS
        )
        self.refresh_btn.pack(side=tk.LEFT, padx=5)
        
        self.auto_refresh_var = tk.BooleanVar(value=True)
        self.auto_refresh_cb = ttkb.Checkbutton(
            controls_frame,
            text="Auto Refresh (60s)",
            variable=self.auto_refresh_var,
            bootstyle=INFO
        )
        self.auto_refresh_cb.pack(side=tk.LEFT, padx=5)
        
        self.status_label = ttkb.Label(
            controls_frame,
            text="Last refresh: Never",
            bootstyle=SECONDARY
        )
        self.status_label.pack(side=tk.RIGHT)
    
    def create_server_cards(self):
        # Clear existing frames
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        self.server_frames = []
        
        # Create a card for each server
        for i, server in enumerate(self.servers):
            card = ttkb.Frame(
                self.scrollable_frame,
                padding=15,
                bootstyle="light",
                relief=tk.RAISED,
                borderwidth=1
            )
            card.grid(row=i, column=0, sticky="ew", padx=5, pady=5, ipadx=10, ipady=10)
            self.server_frames.append(card)
            
            # Server name header
            header = ttkb.Label(
                card,
                text=server["name"],
                font=('Helvetica', 12, 'bold'),
                bootstyle=PRIMARY
            )
            header.grid(row=0, column=0, columnspan=4, sticky="w", pady=(0, 10))
            
            # First row of metrics
            metrics_row1 = ttkb.Frame(card)
            metrics_row1.grid(row=1, column=0, columnspan=4, sticky="ew")
            
            # Ping status
            ping_frame = ttkb.Frame(metrics_row1)
            ping_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(ping_frame, text="Ping:", font=('Helvetica', 9)).pack()
            self.ping_label = ttkb.Label(
                ping_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.ping_label.pack()
            
            # RDP status
            rdp_frame = ttkb.Frame(metrics_row1)
            rdp_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(rdp_frame, text="RDP:", font=('Helvetica', 9)).pack()
            self.rdp_label = ttkb.Label(
                rdp_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.rdp_label.pack()
            
            # Second row of metrics (with meters)
            metrics_row2 = ttkb.Frame(card)
            metrics_row2.grid(row=2, column=0, columnspan=4, sticky="ew", pady=10)
            
            # C: Drive Meter
            c_drive_frame = ttkb.Frame(metrics_row2)
            c_drive_frame.pack(side=tk.LEFT, padx=15)
            ttkb.Label(c_drive_frame, text="C: Drive", font=('Helvetica', 9)).pack()
            self.c_drive_meter = Meter(
                c_drive_frame,
                metersize=100,
                padding=5,
                amountused=0,
                metertype="semi",
                stripethickness=10,
                showtext=True,
                interactive=False,
                textright="%",
                bootstyle=PRIMARY
            )
            self.c_drive_meter.pack()
            
            # D: Drive Meter
            d_drive_frame = ttkb.Frame(metrics_row2)
            d_drive_frame.pack(side=tk.LEFT, padx=15)
            ttkb.Label(d_drive_frame, text="D: Drive", font=('Helvetica', 9)).pack()
            self.d_drive_meter = Meter(
                d_drive_frame,
                metersize=100,
                padding=5,
                amountused=0,
                metertype="semi",
                stripethickness=10,
                showtext=True,
                interactive=False,
                textright="%",
                bootstyle=PRIMARY
            )
            self.d_drive_meter.pack()
            
            # Third row of metrics
            metrics_row3 = ttkb.Frame(card)
            metrics_row3.grid(row=3, column=0, columnspan=4, sticky="ew")
            
            # CPU
            cpu_frame = ttkb.Frame(metrics_row3)
            cpu_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(cpu_frame, text="CPU:", font=('Helvetica', 9)).pack()
            self.cpu_label = ttkb.Label(
                cpu_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.cpu_label.pack()
            
            # RAM
            ram_frame = ttkb.Frame(metrics_row3)
            ram_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(ram_frame, text="RAM:", font=('Helvetica', 9)).pack()
            self.ram_label = ttkb.Label(
                ram_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.ram_label.pack()
            
            # Uptime
            uptime_frame = ttkb.Frame(metrics_row3)
            uptime_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(uptime_frame, text="Uptime:", font=('Helvetica', 9)).pack()
            self.uptime_label = ttkb.Label(
                uptime_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.uptime_label.pack()
            
            # Last checked
            last_frame = ttkb.Frame(metrics_row3)
            last_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(last_frame, text="Last Checked:", font=('Helvetica', 9)).pack()
            self.last_label = ttkb.Label(
                last_frame,
                text="Never",
                font=('Helvetica', 10)
            )
            self.last_label.pack()
    
    def start_update_thread(self):
        self.update_thread = threading.Thread(
            target=self.process_updates,
            daemon=True
        )
        self.update_thread.start()
    
    def process_updates(self):
        while self.running:
            try:
                update = self.update_queue.get(timeout=1)
                if update:
                    server_idx, data = update
                    self.update_server_status(server_idx, data)
            except queue.Empty:
                continue
    
    def update_server_status(self, server_idx, data):
        card = self.server_frames[server_idx]
        
        # Get all widgets from this card
        children_widgets = []
        for child in card.winfo_children():
            children_widgets.append(child)
            children_widgets.extend(child.winfo_children())
        
        # Extract the specific widgets we need to update
        labels = [w for w in children_widgets if isinstance(w, ttkb.Label)]
        meters = [w for w in children_widgets if isinstance(w, Meter)]
        
        # Update ping
        if "ping" in data:
            ping_text = f"{data['ping']:.0f}ms" if data['ping'] != "Down" else "Down"
            labels[2].config(text=ping_text)
            labels[2].config(bootstyle=SUCCESS if data['ping'] != "Down" else DANGER)
        
        # Update RDP
        if "rdp" in data:
            rdp_text = "Open" if data['rdp'] else "Closed"
            labels[5].config(text=rdp_text)
            labels[5].config(bootstyle=SUCCESS if data['rdp'] else DANGER)
        
        # Update C: Drive meter
        if "c_drive" in data and data['c_drive'] != "N/A":
            meters[0].configure(amountused=data['c_drive'])
            if data['c_drive'] < 80:
                meters[0].configure(bootstyle=SUCCESS)
            elif data['c_drive'] < 90:
                meters[0].configure(bootstyle=WARNING)
            else:
                meters[0].configure(bootstyle=DANGER)
        
        # Update D: Drive meter
        if "d_drive" in data and data['d_drive'] != "N/A":
            meters[1].configure(amountused=data['d_drive'])
            if data['d_drive'] < 80:
                meters[1].configure(bootstyle=SUCCESS)
            elif data['d_drive'] < 90:
                meters[1].configure(bootstyle=WARNING)
            else:
                meters[1].configure(bootstyle=DANGER)
        
        # Update CPU
        if "cpu" in data and data['cpu'] != "N/A":
            labels[10].config(text=f"{data['cpu']}%")
            if data['cpu'] < 70:
                labels[10].config(bootstyle=SUCCESS)
            elif data['cpu'] < 90:
                labels[10].config(bootstyle=WARNING)
            else:
                labels[10].config(bootstyle=DANGER)
        
        # Update RAM
        if "ram" in data and data['ram'] != "N/A":
            labels[13].config(text=f"{data['ram']}%")
            if data['ram'] < 70:
                labels[13].config(bootstyle=SUCCESS)
            elif data['ram'] < 90:
                labels[13].config(bootstyle=WARNING)
            else:
                labels[13].config(bootstyle=DANGER)
        
        # Update uptime
        if "uptime" in data and data['uptime'] != "N/A":
            uptime_str = str(timedelta(seconds=data['uptime'])).split('.')[0]
            labels[16].config(text=uptime_str)
        
        # Update last checked
        if "last_checked" in data:
            labels[19].config(text=data['last_checked'].strftime("%Y-%m-%d %H:%M:%S"))
        
        # Update status label
        self.status_label.config(text=f"Last refresh: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    def check_server_status(self, server_idx):
        server = self.servers[server_idx]
        result = {}
        
        try:
            # Ping check
            try:
                ping_response = pythonping.ping(server["ip"], count=2, timeout=2)
                if ping_response.success():
                    result["ping"] = ping_response.rtt_avg_ms
                else:
                    result["ping"] = "Down"
            except Exception:
                result["ping"] = "Down"
            
            # RDP check
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result["rdp"] = sock.connect_ex((server["ip"], server["rdp_port"])) == 0
                sock.close()
            except Exception:
                result["rdp"] = False
            
            # WMI checks
            try:
                wmi_conn = wmi.WMI(
                    computer=server["ip"],
                    user=server["username"],
                    password=server["password"]
                )
                
                # Drive space
                for disk in wmi_conn.Win32_LogicalDisk(DriveType=3):
                    if disk.DeviceID == "C:":
                        total = int(disk.Size)
                        free = int(disk.FreeSpace)
                        result["c_drive"] = round(100 - (free / total * 100), 1)
                    elif disk.DeviceID == "D:":
                        total = int(disk.Size)
                        free = int(disk.FreeSpace)
                        result["d_drive"] = round(100 - (free / total * 100), 1)
                
                # CPU usage
                cpu_usage = wmi_conn.Win32_Processor()[0].LoadPercentage
                result["cpu"] = cpu_usage
                
                # RAM usage
                os = wmi_conn.Win32_OperatingSystem()[0]
                total_ram = int(os.TotalVisibleMemorySize)
                free_ram = int(os.FreePhysicalMemory)
                result["ram"] = round(100 - (free_ram / total_ram * 100), 1)
                
                # Uptime
                last_boot = datetime.strptime(os.LastBootUpTime.split('.')[0], '%Y%m%d%H%M%S')
                result["uptime"] = (datetime.now() - last_boot).total_seconds()
                
            except Exception:
                result["c_drive"] = "N/A"
                result["d_drive"] = "N/A"
                result["cpu"] = "N/A"
                result["ram"] = "N/A"
                result["uptime"] = "N/A"
            
            result["last_checked"] = datetime.now()
            
        except Exception:
            pass
        
        # Put result in queue
        self.update_queue.put((server_idx, result))
    
    def check_all_servers(self):
        if not self.running:
            return
            
        threads = []
        for i in range(len(self.servers)):
            t = threading.Thread(target=self.check_server_status, args=(i,))
            t.start()
            threads.append(t)
        
        # Schedule next check if auto-refresh is enabled
        if self.auto_refresh_var.get():
            self.schedule_next_check()
    
    def schedule_next_check(self):
        if self.check_after_id:
            self.master.after_cancel(self.check_after_id)
        
        self.check_after_id = self.master.after(60000, self.check_all_servers)
    
    def force_refresh(self):
        self.check_all_servers()
    
    def on_close(self):
        self.running = False
        if self.check_after_id:
            self.master.after_cancel(self.check_after_id)
        self.master.destroy()

if __name__ == "__main__":
    root = ttkb.Window(themename="solar")
    app = ServerHealthDashboard(root)
    root.protocol("WM_DELETE_WINDOW", app.on_close)
    root.after(100, app.check_all_servers)  # Initial check after 100ms
    root.mainloop()
