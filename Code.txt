import tkinter as tk
from tkinter import ttk
import ttkbootstrap as ttkb
from ttkbootstrap.constants import *
import threading
import queue
import pythonping
import wmi
from datetime import datetime, timedelta
import socket
import math

class Meter(ttk.Frame):
    """Custom meter widget to replace ttkbootstrap.dial.Meter"""
    def __init__(self, master, size=100, amountused=0, **kwargs):
        super().__init__(master, **kwargs)
        self.size = size
        self.amountused = amountused
        self.canvas = tk.Canvas(self, width=size, height=size//2, 
                               bg=self.cget('bg'), highlightthickness=0)
        self.canvas.pack()
        self.text = self.canvas.create_text(size//2, size//3, 
                                          text=f"{amountused}%", 
                                          font=('Helvetica', 10, 'bold'))
        self.draw_meter()
        
    def draw_meter(self):
        self.canvas.delete("meter")
        size = self.size
        start_angle = 0
        extent_angle = 180
        
        # Draw background arc
        self.canvas.create_arc(5, 5, size-5, size-5, 
                             start=start_angle, extent=extent_angle,
                             outline="#e0e0e0", width=10, style="arc", tags="meter")
        
        # Calculate angle based on amount used (0-100%)
        used_angle = extent_angle * (self.amountused / 100)
        
        # Determine color based on usage
        if self.amountused < 80:
            color = SUCCESS
        elif self.amountused < 90:
            color = WARNING
        else:
            color = DANGER
        
        # Draw usage arc
        self.canvas.create_arc(5, 5, size-5, size-5, 
                             start=start_angle, extent=used_angle,
                             outline=color, width=10, style="arc", tags="meter")
        
        # Update text
        self.canvas.itemconfig(self.text, text=f"{self.amountused}%")
    
    def configure(self, amountused=None, **kwargs):
        if amountused is not None:
            self.amountused = amountused
            self.draw_meter()
        super().configure(**kwargs)

class ServerHealthDashboard:
    def __init__(self, master):
        self.master = master
        master.title("Windows Server Health Dashboard")
        master.geometry("1400x800")
        
        # Server list - replace with your actual servers
        self.servers = [
            {"name": "Server1", "ip": "192.168.1.1", "rdp_port": 3389, 
             "username": "admin", "password": "password"},
            {"name": "Server2", "ip": "192.168.1.2", "rdp_port": 3389, 
             "username": "admin", "password": "password"},
            # Add more servers...
        ]
        
        self.create_widgets()
        self.update_queue = queue.Queue()
        self.running = True
        self.start_update_thread()
        self.check_after_id = None
        self.schedule_next_check()
        self.server_frames = []
        
    def create_widgets(self):
        # Main container
        main_frame = ttkb.Frame(self.master, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Header
        header = ttkb.Label(
            main_frame, 
            text="Windows Server Health Dashboard", 
            font=('Helvetica', 16, 'bold'),
            bootstyle=PRIMARY
        )
        header.pack(pady=(0, 20))
        
        # Create scrollable dashboard area
        self.canvas = ttkb.Canvas(main_frame)
        self.scrollbar = ttkb.Scrollbar(main_frame, orient=tk.VERTICAL, 
                                       command=self.canvas.yview)
        self.scrollable_frame = ttkb.Frame(self.canvas)
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(
                scrollregion=self.canvas.bbox("all")
            )
        )
        
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Create server status cards
        self.create_server_cards()
        
        # Controls frame
        controls_frame = ttkb.Frame(main_frame)
        controls_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.refresh_btn = ttkb.Button(
            controls_frame,
            text="Refresh Now",
            command=self.force_refresh,
            bootstyle=SUCCESS
        )
        self.refresh_btn.pack(side=tk.LEFT, padx=5)
        
        self.auto_refresh_var = tk.BooleanVar(value=True)
        self.auto_refresh_cb = ttkb.Checkbutton(
            controls_frame,
            text="Auto Refresh (60s)",
            variable=self.auto_refresh_var,
            bootstyle=INFO
        )
        self.auto_refresh_cb.pack(side=tk.LEFT, padx=5)
        
        self.status_label = ttkb.Label(
            controls_frame,
            text="Last refresh: Never",
            bootstyle=SECONDARY
        )
        self.status_label.pack(side=tk.RIGHT)
    
    def create_server_cards(self):
        # Clear existing frames
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        self.server_frames = []
        
        # Create a card for each server
        for i, server in enumerate(self.servers):
            card = ttkb.Frame(
                self.scrollable_frame,
                padding=15,
                bootstyle="light",
                relief=tk.RAISED,
                borderwidth=1
            )
            card.grid(row=i, column=0, sticky="ew", padx=5, pady=5, ipadx=10, ipady=10)
            self.server_frames.append(card)
            
            # Server name header
            header = ttkb.Label(
                card,
                text=server["name"],
                font=('Helvetica', 12, 'bold'),
                bootstyle=PRIMARY
            )
            header.grid(row=0, column=0, columnspan=4, sticky="w", pady=(0, 10))
            
            # First row of metrics
            metrics_row1 = ttkb.Frame(card)
            metrics_row1.grid(row=1, column=0, columnspan=4, sticky="ew")
            
            # Ping status
            ping_frame = ttkb.Frame(metrics_row1)
            ping_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(ping_frame, text="Ping:", font=('Helvetica', 9)).pack()
            self.ping_label = ttkb.Label(
                ping_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.ping_label.pack()
            
            # RDP status
            rdp_frame = ttkb.Frame(metrics_row1)
            rdp_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(rdp_frame, text="RDP:", font=('Helvetica', 9)).pack()
            self.rdp_label = ttkb.Label(
                rdp_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.rdp_label.pack()
            
            # Second row of metrics (with meters)
            metrics_row2 = ttkb.Frame(card)
            metrics_row2.grid(row=2, column=0, columnspan=4, sticky="ew", pady=10)
            
            # C: Drive Meter
            c_drive_frame = ttkb.Frame(metrics_row2)
            c_drive_frame.pack(side=tk.LEFT, padx=15)
            ttkb.Label(c_drive_frame, text="C: Drive", font=('Helvetica', 9)).pack()
            self.c_drive_meter = Meter(
                c_drive_frame,
                size=120,
                amountused=0
            )
            self.c_drive_meter.pack()
            
            # D: Drive Meter
            d_drive_frame = ttkb.Frame(metrics_row2)
            d_drive_frame.pack(side=tk.LEFT, padx=15)
            ttkb.Label(d_drive_frame, text="D: Drive", font=('Helvetica', 9)).pack()
            self.d_drive_meter = Meter(
                d_drive_frame,
                size=120,
                amountused=0
            )
            self.d_drive_meter.pack()
            
            # Third row of metrics
            metrics_row3 = ttkb.Frame(card)
            metrics_row3.grid(row=3, column=0, columnspan=4, sticky="ew")
            
            # CPU
            cpu_frame = ttkb.Frame(metrics_row3)
            cpu_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(cpu_frame, text="CPU:", font=('Helvetica', 9)).pack()
            self.cpu_label = ttkb.Label(
                cpu_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.cpu_label.pack()
            
            # RAM
            ram_frame = ttkb.Frame(metrics_row3)
            ram_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(ram_frame, text="RAM:", font=('Helvetica', 9)).pack()
            self.ram_label = ttkb.Label(
                ram_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.ram_label.pack()
            
            # Uptime
            uptime_frame = ttkb.Frame(metrics_row3)
            uptime_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(uptime_frame, text="Uptime:", font=('Helvetica', 9)).pack()
            self.uptime_label = ttkb.Label(
                uptime_frame,
                text="Checking...",
                font=('Helvetica', 10, 'bold')
            )
            self.uptime_label.pack()
            
            # Last checked
            last_frame = ttkb.Frame(metrics_row3)
            last_frame.pack(side=tk.LEFT, padx=10)
            ttkb.Label(last_frame, text="Last Checked:", font=('Helvetica', 9)).pack()
            self.last_label = ttkb.Label(
                last_frame,
                text="Never",
                font=('Helvetica', 10)
            )
            self.last_label.pack()
    
    # [Rest of the methods remain the same as in the previous example]
    # ... (update_server_status, check_server_status, etc.)

if __name__ == "__main__":
    root = ttkb.Window(themename="solar")
    app = ServerHealthDashboard(root)
    root.protocol("WM_DELETE_WINDOW", app.on_close)
    root.after(100, app.check_all_servers)  # Initial check after 100ms
    root.mainloop()
