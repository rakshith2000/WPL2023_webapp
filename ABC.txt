import ttkbootstrap as ttkb
from ttkbootstrap.constants import *
from ttkbootstrap.style import Style
from ttkbootstrap.scrolled import ScrolledFrame
from tkinter import filedialog
import tkinter as tk
from tkinter import ttk
import psutil, wmi, socket, platform, subprocess, paramiko, re, csv
from datetime import datetime
import threading
from queue import Queue
from concurrent.futures import ThreadPoolExecutor
import pythoncom
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.colors import LinearSegmentedColormap
import tkinter.font as tkfont
from tkinter import Canvas

class SystemHealthCheckDashboard(ttkb.Frame):
    def __init__(self, master):
        super().__init__(master)
        self.pack(fill="both", expand=True)
        
        self.table_canvas_windows = None
        self.table_canvas_linux = None
        self.table_canvas_db = None
        self.table_canvas_db_cd = None
        self.table_font = None
        self.header_bg = "#2c3e50"
        self.header_fg = "#ffffff"
        self.alt_bg = "#f8f9fa"
        self.cell_height = 22
        self.padding = 10
        
        user1 = "kosv1106" #Windows 6 servers
        password1 = "c3RM21nvPx2&%32fsp93v"
        
        user2 = "kosv1388" #Linux servers
        password2 = "M7!k28p&c30tyBt1"
        
        self.server_credentials = {
            "USWIW1489": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1490": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1492": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1530": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1531": {"type": "Windows", "user": user1, "password": password1},
            "USWIW1533": {"type": "Windows", "user": user1, "password": password1},
            "USWIW714": {"type": "Windows", "user": user1, "password": password1},
            "USWIW715": {"type": "Windows", "user": user1, "password": password1},
            "USWIW716": {"type": "Windows", "user": user1, "password": password1},
            "USWIX846": {"type": "Linux", "user": user2, "password": password2},
        }

        # Configure grid layout
        self.columnconfigure(0, weight=0)  # Left pane (fixed)
        self.columnconfigure(1, weight=1)  # Right content area (expandable)
        self.rowconfigure(0, weight=0)  # Header (fixed height)
        self.rowconfigure(1, weight=1)  # Main area (expandable)
        
        self.cmap_red_yellow_green = LinearSegmentedColormap.from_list(
            'ryg', ['#4caf50', '#ffeb3b', '#f44336'])
        self.create_header()
        self.create_left_pane()
        self.create_main_area()
        
        self.windows_details = {}  # To store Windows server metrics
        self.linux_details = {}    # To store Linux server metrics
        self.canvases = []         # For matplotlib canvases
        self.figures = []          # For matplotlib figures
        self.axes = []             # For matplotlib axes
        self.c_drive_meters = []   # To store C drive meter widgets
        self.d_drive_meters = []   # To store D drive meter widgets
        
        plt.style.use('seaborn')

    def create_header(self):
        header_frame = ttkb.Frame(self, padding=10, bootstyle=PRIMARY)
        header_frame.grid(row=0, column=0, columnspan=2, sticky="nsew")

        header_lbl = ttkb.Label(
            master=header_frame,
            text="JDA Application Healthcheck Dashboard",
            bootstyle=(PRIMARY, INVERSE),
            font=("Helvetica", 18, "bold"),
            anchor='center'
        )
        header_lbl.pack(fill="x", expand=True)

    def create_left_pane(self):
        style = ttkb.Style()
        style.configure('Overview.TButton', font=('Calibri', 14, 'bold'))
        style.configure('Export.TButton', font=('Calibri', 12, 'bold'))
        
        left_pane = ttkb.Frame(self, padding=10, bootstyle=LIGHT, width=220)
        left_pane.grid(row=1, column=0, sticky="ns")
        left_pane.grid_propagate(False)

        self.overview_btn = ttkb.Button(
            left_pane,
            text="JDA Overview",
            bootstyle="success",
            style='Overview.TButton',
            command=self.start_metrics_collection_thread
        )
        self.overview_btn.pack(fill="x", pady=(0, 20))
        self.export_btn = ttkb.Button(
            left_pane,
            text="Export Data",
            bootstyle="info",
            style='Export.TButton',
            command=self.export_to_csv,
            state="disabled"  # Initially disabled
        )
        self.export_btn.pack(fill="x", pady=(0, 20))
        
    def create_main_area(self):
        self.main_area = ttkb.Frame(self, padding=(10, 10, 10, 10), )
        self.main_area.grid(row=1, column=1, sticky="nsew")
        
        self.content_frame = ScrolledFrame(self.main_area, autohide=True, bootstyle=LIGHT)
        self.content_frame.pack(fill="both", expand=True)
        
        self.placeholder = ttkb.Label(
            self.content_frame,
            text="Click 'JDA Overview' to fetch server metrics",
            font=("Calibri", 14, "bold"),
            bootstyle=INFO
        )
        self.placeholder.pack(expand=True)
        
    def check_rdp_connectivity(self, server, port=3389):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            result = sock.connect_ex((server, port))
            sock.close()
            return result == 0
        except Exception:
            return False
        
    def get_windows_metrics(self, server, credentials):
        metrics = {
            'ping': False,
            'rdp/ssh': False,
            'cpu_usage': 0,
            'ram_usage': 0,
            'ram_detailed': {'total': 0, 'used': 0},
            'C_drive': 0,
            'C_detailed': {'total': 0, 'used': 0},
            'D_drive': 0,
            'D_detailed': {'total': 0, 'used': 0},
            'uptime': "0 Days 0 Hrs",
            'status': 'Offline',
            'moca_serv' : '-',
            'refs_serv' : '-',
            'blueyonder_serv' : '-',
        }
        
        try:
            pythoncom.CoInitialize()  # Initialize COM for this thread... # Check ping
            ping_result = subprocess.run(['ping', '-n', '2', server], 
                                       capture_output=True, 
                                       text=True).returncode
            metrics['ping'] = ping_result == 0
            
            if not metrics['ping']:
                return {server: metrics}
                
            # Check RDP
            metrics['rdp/ssh'] = self.check_rdp_connectivity(server)
            
            # Connect via WMI
            conn = wmi.WMI(server, 
                          user=credentials['user'], 
                          password=credentials['password'])
            
            # CPU Usage
            metrics['cpu_usage'] = 0 if conn.Win32_Processor()[0].LoadPercentage == None else conn.Win32_Processor()[0].LoadPercentage
            metrics['cpu_usage'] = 0 if metrics['cpu_usage'] is None else metrics['cpu_usage']
            
            # RAM Usage
            total_ram = int(conn.Win32_ComputerSystem()[0].TotalPhysicalMemory)
            free_ram = int(conn.Win32_OperatingSystem()[0].FreePhysicalMemory) * 1024
            metrics['ram_usage'] = round(((total_ram - free_ram) / total_ram) * 100, 1)
            metrics['ram_detailed'] = {
                                        'total': round(total_ram / (1024 ** 3), 2),
                                        'used': round((total_ram / (1024 ** 3)) - (free_ram / (1024 ** 3)), 2)
                                        }
            #Uptime
            last_boot = datetime.strptime(conn.Win32_OperatingSystem()[0].LastBootUpTime.split('.')[0], '%Y%m%d%H%M%S')
            uptime = datetime.now() - last_boot
            uptime_days = uptime.days
            uptime_hours = uptime.seconds // 3600
            metrics['uptime'] = f"{uptime_days} Days {uptime_hours} Hrs"
            # Drive Usage (C: and D:)
            drives = conn.Win32_LogicalDisk(DriveType=3)
            for drive in drives:
                if drive.DeviceID == "C:":
                    metrics['C_drive'] = round((int(drive.Size) - int(drive.FreeSpace)) / int(drive.Size) * 100, 1)
                    metrics['C_detailed'] = {
                                            'total' : round(int(drive.Size) / (1024 ** 3), 2),
                                            'used' : round((int(drive.Size) - int(drive.FreeSpace)) / (1024 ** 3), 2)
                                            }
                elif drive.DeviceID == "D:":
                    metrics['D_drive'] = round((int(drive.Size) - int(drive.FreeSpace)) / int(drive.Size) * 100, 1)
                    metrics['D_detailed'] = {
                                            'total' : round(int(drive.Size) / (1024 ** 3), 2),
                                            'used' : round((int(drive.Size) - int(drive.FreeSpace)) / (1024 ** 3), 2)
                                            }
            metrics['status'] = 'Online'
            
            def get_service_stats():
                service_patterns = {
                    'moca_serv': 'moca*',
                    'refs_serv': 'REFS*',
                    'blueyonder_serv': 'RedPrairie*'
                }
                
                results = {key: "-" for key in service_patterns.keys()}
                

                # Query for all services
                for service in conn.Win32_Service():
                    for key, pattern in service_patterns.items():
                        if results[key] != "-":
                            continue
                        regex_pattern = pattern.replace('*', '.*').replace('?', '.')
                        regex_pattern = f"^{regex_pattern}$"
                        
                        # Match service name using the regex pattern (case-insensitive)
                        if re.match(regex_pattern, service.Name, re.IGNORECASE):
                            display_name = service.DisplayName
                            display_suffix = f" ({display_name.split('(')[1]}" if '(' in display_name else ""
                            results[key] = f"{service.State}{display_suffix}"
                            break
                            
                return results
            service_stats = get_service_stats()
            metrics.update(service_stats)
        except Exception as e:
            print(f"Error getting metrics for {server}: {e}")
        finally:
            pythoncom.CoUninitialize()  # Clean up COM for this thread
        
        return {server: metrics}

    def get_linux_metrics(self, server, credentials):
        metrics = {
            'ping': False,
            'rdp/ssh': False,
            'cpu_usage': 0,
            'ram_usage': 0,
            'swap_usage': 0,
            'faulted_resources' : 'NA',
            'fs_usage' : "None",
            'pmon_stat' : "No DB instances\nfound",
            'tns_stat' : "No Listners\nfound",
            'daily_backup' : "No Active daily\nbackup running",
            'weekly_backup' : "No Active weekly\nbackup running",
            'archive_log' : "Not archive log\nfiles found",
            'checkdown' : "Not Found",
            'cluster_ping' : False,
            'ram_detailed': {'total': 0, 'used': 0},
            'C_drive': 0,
            'C_detailed': {'total': 0, 'used': 0},
            'D_drive': 0,
            'D_detailed': {'total': 0, 'used': 0},
            'uptime' : "0 Days 0 Hrs",
            'status': 'offline'
        }
        try:
            ping_result = subprocess.run(['ping', '-n', '2', server], 
                                       capture_output=True, 
                                       text=True).returncode
            metrics['ping'] = ping_result == 0
            
            cluster_ping = subprocess.run(['ping', '-n', '2', "10.20.54.247"], 
                                       capture_output=True, 
                                       text=True).returncode
            metrics['cluster_ping'] = cluster_ping == 0
            
            if not metrics['ping']:
                return {server: metrics}
                
            # Check SSH
            metrics['rdp/ssh'] = self.check_rdp_connectivity(server, port=22)
            
            def execute_command(ssh_client, command):
                stdin, stdout, stderr = ssh_client.exec_command(command)
                return stdout.read().decode('utf-8')
                
            def get_swap_utilization(ssh_client):
                command = "free -m | awk '/Swap:/ {print $3,$2}'"
                output = execute_command(ssh_client, command)
                
                for line in output.splitlines():
                    used, total = line.split()
                    swap_percentage = round((int(used) / int(total)) * 100, 2)
                return {'swap_usage' : swap_percentage}
                
            def get_faulted_resources(ssh_client):
                command = "sudo /opt/VRTS/bin/hastatus -sum"
                output = execute_command(ssh_client, command)
                return {"faulted_resources": output.strip() if output.strip() else 'NA'}
            
            def get_db_stat(ssh_client):
                command = """ps -ef | grep [p]mon | awk '$1 == "oracle" {print $1, $8}'"""
                output = execute_command(ssh_client, command)
                return output.splitlines()
                
            def get_listner_stat(ssh_client):
                command = """ps -ef | grep [t]ns | awk '$1 == "oracle" {print $1, $8}'"""
                output = execute_command(ssh_client, command)
                return output.splitlines()
                
            def get_daily_bkup_stat(ssh_client):
                command = """ps -ef | grep [d]aily | awk '{print $1, $5, $7, $8}'"""
                output = execute_command(ssh_client, command)
                return output.splitlines()
                
            def get_weekly_bkup_stat(ssh_client):
                command = """ps -ef | grep [w]eekly | awk '{print $1, $5, $7, $8}'"""
                output = execute_command(ssh_client, command)
                return output.splitlines()
                
            def get_archive_logs_stat(ssh_client):
                command = """df -h /oralogs* | grep /oralogs* | awk '{print $1, $5, $6}'"""
                output = execute_command(ssh_client, command)
                return output.splitlines()
                
            def get_checkdown_stat(ssh_client):
                command = """/common/oracle/checkdown"""
                output = execute_command(ssh_client, command)
                return output.splitlines()
                
            def get_fs_utilization(ssh_client):
                fs_utilization = {}
                command = "df -hlPT | egrep -v 'tmpfs|Type'"
                output = execute_command(ssh_client, command)
                
                for line in output.splitlines():
                    parts = line.split()
                    if len(parts) > 6:
                        utilization = int(re.search(r'(\d+)%', parts[5]).group(1))
                        if utilization > 90:
                            fs_utilization[parts[6]] = int(parts[5].split('%')[0])
                return fs_utilization if fs_utilization else "None"
            
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            client.connect(hostname=server, username=credentials['user'], password=credentials['password'], timeout=5)
            
            stdin, stdout, stderr = client.exec_command("""
                            cat /etc/os-release | grep ^NAME=;
                            cat /etc/os-release | grep ^VERSION=;
                            nproc;
                            free -b | awk '/Mem:/{print $2}';
                            uptime -s;
                            top -bn1 | grep 'Cpu(s)' | awk '{print $2 + $4}';
                            free -b | awk '/Mem:/{print $2, $3}';
                            df -B1 / | awk 'NR==2 {print $1,$2,$3,$6}'
                            """)
            output = stdout.read().decode().splitlines()
            total_ram_bytes = int(output[3])
            uptime_days = (datetime.now() - datetime.strptime(output[4], "%Y-%m-%d %H:%M:%S")).days
            cpu_usage = float(output[5])
            total_ram_gb = round(total_ram_bytes / (1024**3), 2)
            used_ram_gb = round(int(output[6].split()[1]) / (1024**3), 2)
            disks = []
            for line in output[7:]:
                if not line.strip() or 'Filesystem' in line:
                    continue
                parts = line.split()
                try:
                    disks.append({
                        "disk": parts[0],
                        "total_gb": round(int(parts[1]) / (1024**3), 2),
                        "used_gb": round(int(parts[2]) / (1024**3), 2)
                    })
                except (ValueError, IndexError):
                    continue
            metrics['cpu_usage'] = cpu_usage
            metrics['ram_usage'] = round((used_ram_gb/total_ram_gb) * 100, 1)
            metrics['ram_detailed'] = {
                                        'total' : total_ram_gb,
                                        'used' : used_ram_gb
                                        }
            metrics['uptime'] = uptime_days
            metrics['C_drive'] = round((disks[0]['used_gb']/disks[0]['total_gb']) * 100, 1)
            metrics['C_detailed'] = {
                                        'total' : disks[0]['total_gb'],
                                        'used' : disks[0]['used_gb']
                                        }
            metrics['status'] = 'Online'
            swap_usage = get_swap_utilization(client)
            metrics['swap_usage'] = swap_usage['swap_usage']
            faulted_resources = get_faulted_resources(client)
            metrics['faulted_resources'] = faulted_resources['faulted_resources']
            metrics['fs_usage'] = get_fs_utilization(client)
            pmon_stat = get_db_stat(client) 
            metrics['pmon_stat'] = pmon_stat if pmon_stat else "No DB instances\nfound"
            tns_stat = get_listner_stat(client) 
            metrics['tns_stat'] = tns_stat if tns_stat else "No Listners\nfound"
            daily_backup = get_daily_bkup_stat(client) 
            metrics['daily_backup'] = daily_backup if daily_backup else "No Active Daily\nBackup running"
            weekly_backup = get_weekly_bkup_stat(client) 
            metrics['weekly_backup'] = weekly_backup if weekly_backup else "No Active Weekly\nBackup running"
            archive_log = get_archive_logs_stat(client)
            metrics['archive_log'] = archive_log if archive_log else "No archive\nlog files found"
            checkdown = get_checkdown_stat(client)
            metrics['checkdown'] = checkdown if checkdown else "Not found"
            client.close()
        except Exception as e:
            print(f"Error getting metrics for {server}: {e}")
        
        return {server: metrics}

    def get_metrics_worker(self, server, credentials):
        if credentials["type"] == "Windows":
            result = self.get_windows_metrics(server, credentials)
        elif credentials["type"] == "Linux":
            result = self.get_linux_metrics(server, credentials)
        self.result_queue.put(result)
        
    def start_metrics_collection_thread(self):
        self.export_btn.config(state="disabled")
        for widget in self.content_frame.winfo_children():
            widget.destroy()
        loading_label = ttkb.Label(
            self.content_frame,
            text="Collecting metrics from servers...",
            font=("Calibri", 14, "bold"),
            bootstyle=INFO
        )
        loading_label.pack(expand=True)
        self.content_frame.update()
        """Start a thread to collect metrics."""
        self.overview_btn.config(state="disabled")
        threading.Thread(target=self.update_all_metrics).start()

    def update_all_metrics(self):
        # Clear previous metrics
        self.windows_details = {}
        self.linux_details = {}
        
        # Use ThreadPoolExecutor to fetch metrics in parallel in a worker thread
        self.result_queue = Queue()
        with ThreadPoolExecutor(max_workers=10) as executor:
            for server, credentials in self.server_credentials.items():
                executor.submit(self.get_metrics_worker, server, credentials)

        # Schedule periodic checking of the queue to update the UI once metrics are collected
        self.after(100, self.check_metrics_queue)

    def check_metrics_queue(self):
        try:
            while not self.result_queue.empty():
                result = self.result_queue.get_nowait()
                server = list(result.keys())[0]
                if self.server_credentials[server]["type"] == "Windows":
                    self.windows_details.update(result)
                else:
                    self.linux_details.update(result)
            
            # If all metrics are collected, update the UI
            if (len(self.windows_details) + len(self.linux_details)) == len(self.server_credentials):
                # Sort the dictionaries by server name
                self.windows_details = {key: self.windows_details[key] for key in sorted(self.windows_details)}
                self.linux_details = {key: self.linux_details[key] for key in sorted(self.linux_details)}
                
                self.update_gui_after_metrics()
            else:
                # If still waiting, check again after a small delay
                self.after(100, self.check_metrics_queue)
        except Exception as e:
            print(f"Error while processing metrics: {e}")
        finally:
            self.overview_btn.config(state="normal")
            
    def export_to_csv(self):
        """Export the collected metrics to a CSV file with file dialog for path selection"""
        if not self.windows_details and not self.linux_details:
            return
            
        # Create a file dialog to get the save path
        file_path = filedialog.asksaveasfilename(
            title="Save Metrics as CSV",
            initialfile=f"JDA_HC_Data_{datetime.now().strftime('%Y-%m-%d_%H-%M')}.csv",
            filetypes=[('CSV Files', '*.csv')],
            parent=self
        )   
        
        # If user canceled the dialog
        if not file_path:
            return
            
        # Ensure the file has .csv extension
        if not file_path.lower().endswith('.csv'):
            file_path += '.csv'
        
        try:
            with open(file_path, 'w', newline='') as csvfile:
                fieldnames = [
                    'Server', 'Status', 'Type', 'Ping', 'RDP/SSH', 
                    'CPU Usage (%)', 'RAM Usage (%)', 'RAM Total (GB)', 'RAM Used (GB)',
                    'C Drive Usage (%)', 'C Drive Total (GB)', 'C Drive Used (GB)',
                    'D Drive Usage (%)', 'D Drive Total (GB)', 'D Drive Used (GB)',
                    'Uptime'
                ]
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                
                # Write Windows server data
                for server, metrics in self.windows_details.items():
                    writer.writerow({
                        'Server': server,
                        'Status': metrics['status'],
                        'Type': 'Windows',
                        'Ping': metrics['ping'],
                        'RDP/SSH': metrics['rdp/ssh'],
                        'CPU Usage (%)': metrics['cpu_usage'],
                        'RAM Usage (%)': metrics['ram_usage'],
                        'RAM Total (GB)': metrics['ram_detailed']['total'],
                        'RAM Used (GB)': metrics['ram_detailed']['used'],
                        'C Drive Usage (%)': metrics['C_drive'],
                        'C Drive Total (GB)': metrics['C_detailed']['total'],
                        'C Drive Used (GB)': metrics['C_detailed']['used'],
                        'D Drive Usage (%)': metrics['D_drive'],
                        'D Drive Total (GB)': metrics['D_detailed']['total'],
                        'D Drive Used (GB)': metrics['D_detailed']['used'],
                        'Uptime': metrics['uptime']
                    })
                
                # Write Linux server data
                for server, metrics in self.linux_details.items():
                    writer.writerow({
                        'Server': server,
                        'Status': metrics['status'],
                        'Type': 'Linux',
                        'Ping': metrics['ping'],
                        'RDP/SSH': metrics['rdp/ssh'],
                        'CPU Usage (%)': metrics['cpu_usage'],
                        'RAM Usage (%)': metrics['ram_usage'],
                        'RAM Total (GB)': metrics['ram_detailed']['total'],
                        'RAM Used (GB)': metrics['ram_detailed']['used'],
                        'C Drive Usage (%)': metrics['C_drive'],
                        'C Drive Total (GB)': metrics['C_detailed']['total'],
                        'C Drive Used (GB)': metrics['C_detailed']['used'],
                        'D Drive Usage (%)': 'N/A',
                        'D Drive Total (GB)': 'N/A',
                        'D Drive Used (GB)': 'N/A',
                        'Uptime': metrics['uptime']
                    })
            
            # Show success message
            ttkb.dialogs.Messagebox.show_info(
                title="Export Successful",
                message=f"Metrics exported successfully to:\n{file_path}",
                parent=self
            )
        except Exception as e:
            ttkb.dialogs.Messagebox.show_error(
                title="Export Failed",
                message=f"Failed to export metrics:\n{str(e)}",
                parent=self
            )

    def update_gui_after_metrics(self):
        self.display_metrics()
        self.export_btn.config(state="normal")  # Enable export button now that we have data

    def display_metrics(self):
        # Clear previous content
        for widget in self.content_frame.winfo_children():
            widget.destroy()
        
        # Create Treeview
        self.create_canvas_table_windows()
        self.create_canvas_table_linux()
        self.create_canvas_table_db()
        self.create_canvas_table_db_cd()
        # Create plots
        self.create_plots()
        # Update plots with actual data
        self.update_plots_with_metrics()
        
    def create_plots(self):
        """Initialize the empty plots with vertical organization"""
        self.canvases = []
        self.figures = []
        self.axes = []
        
        # Create main container frame
        container_frame = ttkb.Frame(self.content_frame)
        container_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create CPU Usage frame
        cpu_frame = ttkb.LabelFrame(container_frame, text="CPU Usage", bootstyle="cosmo")
        cpu_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=10)
        
        # Create RAM Usage frame
        ram_frame = ttkb.LabelFrame(container_frame, text="RAM Usage", bootstyle="cosmo")
        ram_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=10)
        
        # Create Disk Usage frame
        disk_frame = ttkb.LabelFrame(container_frame, text="Disk Usage", bootstyle="cosmo")
        disk_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=10)
        
        # Create plots for CPU Usage (Windows above Linux)
        self.create_metric_plots(cpu_frame, "CPU")
        
        # Create plots for RAM Usage (Windows above Linux)
        self.create_metric_plots(ram_frame, "RAM")
        
        # Create plots for Disk Usage
        self.create_disk_usage_plots(disk_frame)

    def create_metric_plots(self, parent_frame, metric_type):
        """Create Windows and Linux plots for a specific metric type"""
        # Windows frame
        windows_frame = ttkb.LabelFrame(parent_frame, text="Windows Servers", bootstyle="info")
        windows_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(5, 2))
        
        # Linux frame
        linux_frame = ttkb.LabelFrame(parent_frame, text="Linux Servers", bootstyle="info")
        linux_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(2, 5))
        
        # Create plots for Windows
        fig, ax = plt.subplots(figsize=(8, 3.5))
        self.figures.append(fig)
        self.axes.append(ax)
        
        canvas = FigureCanvasTkAgg(fig, master=windows_frame)
        canvas.draw()
        widget = canvas.get_tk_widget()
        widget.pack(fill=tk.BOTH, expand=True, padx=5, pady=2)
        self.canvases.append(canvas)
        
        # Create plots for Linux
        fig, ax = plt.subplots(figsize=(8, 3.5))
        self.figures.append(fig)
        self.axes.append(ax)
        
        canvas = FigureCanvasTkAgg(fig, master=linux_frame)
        canvas.draw()
        widget = canvas.get_tk_widget()
        widget.pack(fill=tk.BOTH, expand=True, padx=5, pady=2)
        self.canvases.append(canvas)

    def create_disk_usage_plots(self, parent_frame):
        """Create meter plots for disk usage with proper organization"""
        # Clear any existing frames first
        for widget in parent_frame.winfo_children():
            widget.destroy()
        
        # C: Drive frame - only create if we have Windows servers
        if self.windows_details:
            c_drive_frame = ttkb.LabelFrame(parent_frame, text="C: Drive (Windows)", bootstyle="info")
            c_drive_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(5, 2))
            self.create_meter_rows(c_drive_frame, "C")
        
        # D: Drive frame - only create if we have Windows servers
        if self.windows_details:
            d_drive_frame = ttkb.LabelFrame(parent_frame, text="D: Drive (Windows)", bootstyle="info")
            d_drive_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(2, 5))
            self.create_meter_rows(d_drive_frame, "D")

    def create_meter_rows(self, parent_frame, drive_type):
        """Create rows of meters with 5 meters per row and increased size"""
        # Get the appropriate servers and usage data
        servers = []
        usages = []
        
        if drive_type == "C":
            # Add Windows servers first
            for server, metrics in self.windows_details.items():
                servers.append(f"{server} (C:)")
                usages.append(metrics['C_drive'])
            
            # Add Linux servers
            #for server, metrics in self.linux_details.items():
            #    servers.append(f"{server} (/root)")
            #    usages.append(metrics['C_drive'])
        elif drive_type == "D":
            # Only Windows servers have D drive
            for server, metrics in self.windows_details.items():
                servers.append(f"{server} (D:)")
                usages.append(metrics['D_drive'])
        
        # Calculate number of rows needed (5 meters per row)
        num_servers = len(servers)
        if num_servers == 0:
            return
            
        num_rows = (num_servers + 4) // 5  # Round up
        
        for row in range(num_rows):
            row_frame = ttkb.Frame(parent_frame)
            row_frame.pack(fill=tk.X, expand=True)
            
            # Get servers and usages for this row
            start_idx = row * 5
            end_idx = min((row + 1) * 5, num_servers)
            row_servers = servers[start_idx:end_idx]
            row_usages = usages[start_idx:end_idx]
            
            # Create meters for this row with increased size
            for server, usage in zip(row_servers, row_usages):
                meter_style = self.get_meter_style(usage)
                meter = ttkb.Meter(
                    row_frame,
                    amountused=usage,
                    meterthickness=13,  # Increased thickness
                    metersize=150,       # Increased size (default is 75)
                    bootstyle=meter_style,
                    interactive=True,
                    textfont=['Times', 14, 'bold'],  # Larger font
                    textright='%',
                    subtext=server,
                    subtextfont=['Times', 10, 'bold'],  # Larger font
                    subtextstyle="secondary"
                )
                meter.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=5, pady=5)
                
                # Store meter widgets for later updates if needed
                if drive_type == "C":
                    self.c_drive_meters.append(meter)
                else:
                    self.d_drive_meters.append(meter)

    def get_meter_style(self, value):
        """Determine meter style based on threshold"""
        if value >= 95:
            return "danger"
        elif value >= 85:
            return "warning"
        else:
            return "success"
    
    def create_canvas_table_windows(self):
        """Create a canvas-based table to display server metrics"""
        # Create container frame
        container_frame = ttkb.Frame(self.content_frame)
        container_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        win_header = ttkb.Label(
            container_frame,
            text="Windows / JDA Application Servers Status",
            font=("Calibri", 12, "bold"),
            bootstyle=INFO
        )
        win_header.pack(expand=True)
        
        # Create scrollable canvas
        self.table_canvas_windows = Canvas(container_frame, bg="white", highlightthickness=0)
        self.table_canvas_windows.pack(fill="both", expand=True)
        
        # Initialize font
        self.table_font = tkfont.Font(family="Calibri", size=10)
        
        self.table_canvas_windows.bind("<Configure>", lambda e: self.draw_table_windows())
            
    def get_column_widths_windows(self, headers, data, available_width):
        """Calculate column widths based on content"""
        max_text_widths = []
        for col_index in range(len(headers)):
            column_texts = [headers[col_index]] + [str(row[col_index]) for row in data]
            max_width = max(self.table_font.measure(text) for text in column_texts) + self.padding
            max_text_widths.append(max_width)

        total_content_width = sum(max_text_widths)
        
        if total_content_width < available_width:
            # Distribute extra width proportionally
            extra = available_width - total_content_width
            max_text_widths = [w + (extra * w / total_content_width) for w in max_text_widths]
            
        return max_text_widths
    
    def get_metric_color(self, value):
        """Determine color based on metric value"""
        if isinstance(value, str):
            if "%" in value:
                try:
                    num = float(value.replace("%", ""))
                    if num >= 95:
                        return "#c62828"  # Red for critical f44336
                    elif num >= 85:
                        return "#f57c00"  # Orange for warning ff9800
                    else:
                        return "#2e7d32"  # Green for good 4caf50
                except ValueError:
                    return "black"
            return "black"
        else:
            if value >= 95:
                return "#c62828"
            elif value >= 85:
                return "#f57c00"
            else:
                return "#2e7d32"
    
    def draw_table_windows(self):
        """Draw the table with server metrics"""
        if not self.windows_details:
            return
            
        # Prepare headers and data
        headers = [
            "Server", "Type", "Ping", "RDP", 
            "CPU Usage", "RAM Usage", "C Drive", "D Drive", "Uptime", "MOCA Service", "REFS Service", "BlueYonder Service"
        ]
        
        # Combine Windows and Linux data
        data = []
        for server, metrics in self.windows_details.items():
            row = [
                server,
                #metrics['status'],
                self.server_credentials[server]['type'],
                "✔" if metrics['ping'] else "✖",
                "✔" if metrics['rdp/ssh'] else "✖",
                f"{metrics['cpu_usage']}%" if metrics['status'] == 'Online' else "N/A",
                f"{metrics['ram_usage']}%" if metrics['status'] == 'Online' else "N/A",
                f"{metrics['C_drive']}%" if metrics['status'] == 'Online' else "N/A",
                f"{metrics['D_drive']}%" if metrics['status'] == 'Online' and 'D_drive' in metrics else "N/A",
                f"{metrics['uptime']}" if metrics['status'] == 'Online' else "N/A",
                metrics['moca_serv'] if metrics['status'] == 'Online' else "N/A",
                metrics['refs_serv'] if metrics['status'] == 'Online' else "N/A",
                metrics['blueyonder_serv'] if metrics['status'] == 'Online' else "N/A"
            ]
            data.append(row)
        
        # Clear existing items
        self.table_canvas_windows.delete("all")
        
        # Get current canvas width
        canvas_width = self.table_canvas_windows.winfo_width()
        if canvas_width < 100:  # Minimum width
            canvas_width = 1000
            
        # Calculate column widths
        col_widths = self.get_column_widths_windows(headers, data, canvas_width)
        
        # Calculate total height needed
        total_height = ((len(data) + 1) * self.cell_height) + 1
        
        # Configure canvas scroll region
        self.table_canvas_windows.config(height=total_height)
        
        # Draw headers
        x = 0
        for i, header in enumerate(headers):
            w = col_widths[i] - 1 if i == len(headers)-1 else col_widths[i]
            self.table_canvas_windows.create_rectangle(
                x, 0, x + w, self.cell_height, 
                fill=self.header_bg, outline="gray"
            )
            self.table_canvas_windows.create_text(
                x + w // 2, self.cell_height // 2, 
                text=header, fill=self.header_fg, 
                font=("Calibri", 10, "bold")
            )
            x += w
        
        # Draw rows
        for r, row in enumerate(data):
            y0 = (r + 1) * self.cell_height
            y1 = y0 + self.cell_height
            bg_color = self.alt_bg if r % 2 == 0 else "white"
            x = 0
            
            for c, cell in enumerate(row):
                w = col_widths[c] - 1 if c == len(row) - 1 else col_widths[c]
                self.table_canvas_windows.create_rectangle(
                    x, y0, x + w, y1, 
                    fill=bg_color, outline="gray"
                )
                
                # Determine text color based on metric
                if c >= 4 and c <= 7 and "%" in str(cell):  # Metric columns
                    try:
                        value = float(str(cell).replace("%", ""))
                        color = self.get_metric_color(value)
                    except ValueError:
                        color = "black"
                elif c == 2 or c == 3:  # Ping/RDP columns
                    color = "#4caf50" if cell == "✔" else "#f44336"
                elif c >= 9 or c <= 11:
                    if "Running" in cell:
                        color = "#4caf50"
                    elif "Stopped" in cell:
                        color = "#f44336"
                    else:
                        color = 'black'
                else:
                    color = "black"
                
                self.table_canvas_windows.create_text(
                    x + w // 2, (y0 + y1) // 2, 
                    text=cell, fill=color, 
                    font=("Calibri", 10)
                )
                x += w
                
    def create_canvas_table_linux(self):
        """Create a canvas-based table to display server metrics"""
        # Create container frame
        container_frame = ttkb.Frame(self.content_frame)
        container_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        lin_header = ttkb.Label(
            container_frame,
            text="Linux Database Servers Status",
            font=("Calibri", 12, "bold"),
            bootstyle=INFO
        )
        lin_header.pack(expand=True)
        
        # Create scrollable canvas
        self.table_canvas_linux = Canvas(container_frame, bg="white", highlightthickness=0)
        self.table_canvas_linux.pack(fill="both", expand=True)
        
        # Initialize font
        self.table_font = tkfont.Font(family="Calibri", size=10)
        
        self.table_canvas_linux.bind("<Configure>", lambda e: self.draw_table_linux())
            
    def get_column_widths_linux(self, headers, data, available_width):
        """Calculate column widths based on content"""
        max_text_widths = []
        for col_index in range(len(headers)):
            column_texts = [headers[col_index]] + [str(row[col_index]) for row in data]
            max_width = 0
            for text in column_texts:
                lines = text.split('\n') if isinstance(text, str) else [str(text)]
                line_widths = [self.table_font.measure(line) for line in lines]
                max_width = max(max_width, max(line_widths))
            
            max_text_widths.append(max_width + self.padding)

        total_content_width = sum(max_text_widths)
        
        if total_content_width < available_width:
            # Distribute extra width proportionally
            extra = available_width - total_content_width
            max_text_widths = [w + (extra * w / total_content_width) for w in max_text_widths]
            
        return max_text_widths
    
    def draw_table_linux(self):
        """Draw the table with server metrics"""
        if not self.linux_details:
            return
            
        # Prepare headers and data
        headers = [
            "Server", "Type", "Ping", "SSH", 
            "CPU Usage", "RAM Usage", "Swap Usage", "FS Usage (>90%)", "ClusterIP Ping", "Uptime"
        ]
        
        # Combine Windows and Linux data
        data = []
        for server, metrics in self.linux_details.items():
            # FS Usage
            if metrics['status'] == 'Online' and isinstance(metrics['fs_usage'], dict):
                fs_entries = [f"{fs}: {usage}%" for fs, usage in metrics['fs_usage'].items()]
                fs_usage_text = "\n".join(fs_entries) if fs_entries else "None"
            elif metrics['fs_usage'] == "None":
                fs_usage_text = "None"
            else:
                fs_usage_text = "N/A"
            
            # DB Instance Status
            if metrics['status'] == 'Online' and isinstance(metrics['pmon_stat'], list):
                pmon_stat = "\n".join(metrics['pmon_stat'])
            elif isinstance(metrics['pmon_stat'], str):
                pmon_stat = metrics['pmon_stat']
            else:
                pmon_stat = "N/A"
            
            # DB Listner Status
            if metrics['status'] == 'Online' and isinstance(metrics['tns_stat'], list):
                tns_stat = "\n".join(metrics['tns_stat'])
            elif isinstance(metrics['tns_stat'], str):
                tns_stat = metrics['tns_stat']
            else:
                tns_stat = "N/A"
            
            # Daily Backup Status
            if metrics['status'] == 'Online' and isinstance(metrics['daily_backup'], list):
                daily_backup = "\n".join(metrics['daily_backup'])
            elif isinstance(metrics['daily_backup'], str):
                daily_backup = metrics['daily_backup']
            else:
                daily_backup = "N/A"
                
            # Weekly Backup Status    
            if metrics['status'] == 'Online' and isinstance(metrics['weekly_backup'], list):
                weekly_backup = "\n".join(metrics['weekly_backup'])
            elif isinstance(metrics['weekly_backup'], str):
                weekly_backup = metrics['weekly_backup']
            else:
                weekly_backup = "N/A"
                
                
            row = [
                server,
                #metrics['status'],
                self.server_credentials[server]['type'],
                "✔" if metrics['ping'] else "✖",
                "✔" if metrics['rdp/ssh'] else "✖",
                f"{metrics['cpu_usage']}%" if metrics['status'] == 'Online' else "N/A",
                f"{metrics['ram_usage']}%" if metrics['status'] == 'Online' else "N/A",
                f"{metrics['swap_usage']}%" if metrics['status'] == 'Online' else "N/A",
                #f"{metrics['faulted_resources']}" if metrics['status'] == 'Online' else "N/A",
                fs_usage_text,
                "✔" if metrics['cluster_ping'] else "✖",
                f"{metrics['uptime']} Days" if metrics['status'] == 'Online' else "N/A"
            ]
            data.append(row)
        
        # Clear existing items
        self.table_canvas_linux.delete("all")
        
        # Get current canvas width
        canvas_width = self.table_canvas_linux.winfo_width()
        if canvas_width < 100:  # Minimum width
            canvas_width = 1000
            
        # Calculate column widths
        col_widths = self.get_column_widths_linux(headers, data, canvas_width)
        
        row_heights = []
        for row in data:
            max_lines = 1
            for c, cell in enumerate(row):
                if isinstance(cell, str) and "\n" in cell:
                    line_count = cell.count("\n") + 1
                    if line_count > max_lines:
                        max_lines = line_count
            row_heights.append(self.cell_height * max_lines)
            
        # Calculate total height needed
        total_height = sum(row_heights) + self.cell_height + 1
        
        # Configure canvas scroll region
        self.table_canvas_linux.config(height=total_height)
        
        # Draw headers
        x = 0
        for i, header in enumerate(headers):
            w = col_widths[i] - 1 if i == len(headers)-1 else col_widths[i]
            self.table_canvas_linux.create_rectangle(
                x, 0, x + w, self.cell_height, 
                fill=self.header_bg, outline="gray"
            )
            self.table_canvas_linux.create_text(
                x + w // 2, self.cell_height // 2, 
                text=header, fill=self.header_fg, 
                font=("Calibri", 10, "bold")
            )
            x += w
        
        # Draw rows
        y = self.cell_height
        for r, row in enumerate(data):
            row_height = row_heights[r]
            bg_color = self.alt_bg if r % 2 == 0 else "white"
            x = 0
            
            for c, cell in enumerate(row):
                w = col_widths[c] - 1 if c == len(row)-1 else col_widths[c]
                self.table_canvas_linux.create_rectangle(
                    x, y, x + w, y + row_height, 
                    fill=bg_color, outline="gray"
                )
                
                # Determine text color based on metric
                if c >= 4 and c <= 6 and "%" in str(cell):  # Metric columns
                    try:
                        value = float(str(cell).replace("%", ""))
                        color = self.get_metric_color(value)
                    except ValueError:
                        color = "black"
                elif c == 2 or c == 3 or c == 8:  # Ping/RDP columns
                    color = "#4caf50" if cell == "✔" else "#f44336" 
                else:
                    color = "black"
                
                # Draw multi-line text if needed
                if isinstance(cell , str) and "\n" in cell:
                    lines = cell.split("\n")
                    line_spacing = self.table_font.metrics("linespace") + 2
                    text_block_height = len(lines) * line_spacing
                    y_offset = y + (row_height - text_block_height) / 2
                    for i, line in enumerate(lines):
                        self.table_canvas_linux.create_text(
                            x + w // 2, y_offset,
                            anchor="n", text=line,
                            fill=color, font=("Calibri", 10)
                        )
                        y_offset += line_spacing
                else:
                    #Single line
                    self.table_canvas_linux.create_text(
                        x + w // 2, y + row_height // 2, 
                        text=cell, fill=color, 
                        font=("Calibri", 10)
                    )
                x += w
            y += row_height
            
    def create_canvas_table_db(self):
        """Create a canvas-based table to display server metrics"""
        # Create container frame
        container_frame = ttkb.Frame(self.content_frame)
        container_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Create scrollable canvas
        self.table_canvas_db = Canvas(container_frame, bg="white", highlightthickness=0)
        self.table_canvas_db.pack(fill="both", expand=True)
        
        # Initialize font
        self.table_font = tkfont.Font(family="Calibri", size=10)
        
        self.table_canvas_db.bind("<Configure>", lambda e: self.draw_table_db())
            
    def get_column_widths_db(self, headers, data, available_width):
        """Calculate column widths based on content"""
        max_text_widths = []
        for col_index in range(len(headers)):
            column_texts = [headers[col_index]] + [str(row[col_index]) for row in data]
            max_width = 0
            for text in column_texts:
                lines = text.split('\n') if isinstance(text, str) else [str(text)]
                line_widths = [self.table_font.measure(line) for line in lines]
                max_width = max(max_width, max(line_widths))
            
            max_text_widths.append(max_width + self.padding)

        total_content_width = sum(max_text_widths)
        
        if total_content_width < available_width:
            # Distribute extra width proportionally
            extra = available_width - total_content_width
            max_text_widths = [w + (extra * w / total_content_width) for w in max_text_widths]
            
        return max_text_widths
    
    def draw_table_db(self):
        """Draw the table with server metrics"""
        if not self.linux_details:
            return
            
        # Prepare headers and data
        headers = [
            "Server", "DB Status", "Listerner Status", "Archive Logs", "Daily Backup", "Weekly Backup"
        ]
        
        # Combine Windows and Linux data
        data = []
        for server, metrics in self.linux_details.items():
            # FS Usage
            if metrics['status'] == 'Online' and isinstance(metrics['fs_usage'], dict):
                fs_entries = [f"{fs}: {usage}%" for fs, usage in metrics['fs_usage'].items()]
                fs_usage_text = "\n".join(fs_entries) if fs_entries else "None"
            elif metrics['fs_usage'] == "None":
                fs_usage_text = "None"
            else:
                fs_usage_text = "N/A"
            
            # DB Instance Status
            if metrics['status'] == 'Online' and isinstance(metrics['pmon_stat'], list):
                pmon_stat = "\n".join(metrics['pmon_stat'])
            elif isinstance(metrics['pmon_stat'], str):
                pmon_stat = metrics['pmon_stat']
            else:
                pmon_stat = "N/A"
            
            # DB Listner Status
            if metrics['status'] == 'Online' and isinstance(metrics['tns_stat'], list):
                tns_stat = "\n".join(metrics['tns_stat'])
            elif isinstance(metrics['tns_stat'], str):
                tns_stat = metrics['tns_stat']
            else:
                tns_stat = "N/A"
                
            # Archive Logs Status
            if metrics['status'] == 'Online' and isinstance(metrics['archive_log'], list):
                archive_log = "\n".join(metrics['archive_log'])
            elif isinstance(metrics['archive_log'], str):
                archive_log = metrics['archive_log']
            else:
                archive_log = "N/A"
            
            # Daily Backup Status
            if metrics['status'] == 'Online' and isinstance(metrics['daily_backup'], list):
                daily_backup = "\n".join(metrics['daily_backup'])
            elif isinstance(metrics['daily_backup'], str):
                daily_backup = metrics['daily_backup']
            else:
                daily_backup = "N/A"
                
            # Weekly Backup Status    
            if metrics['status'] == 'Online' and isinstance(metrics['weekly_backup'], list):
                weekly_backup = "\n".join(metrics['weekly_backup'])
            elif isinstance(metrics['weekly_backup'], str):
                weekly_backup = metrics['weekly_backup']
            else:
                weekly_backup = "N/A"
                
                
            row = [
                server,
                #metrics['status'],
                #self.server_credentials[server]['type'],
                pmon_stat,
                tns_stat,
                archive_log,
                daily_backup,
                weekly_backup
            ]
            data.append(row)
        
        # Clear existing items
        self.table_canvas_db.delete("all")
        
        # Get current canvas width
        canvas_width = self.table_canvas_db.winfo_width()
        if canvas_width < 100:  # Minimum width
            canvas_width = 1000
            
        # Calculate column widths
        col_widths = self.get_column_widths_db(headers, data, canvas_width)
        
        row_heights = []
        for row in data:
            max_lines = 1
            for c, cell in enumerate(row):
                if isinstance(cell, str) and "\n" in cell:
                    line_count = cell.count("\n") + 1
                    if line_count > max_lines:
                        max_lines = line_count
            row_heights.append(self.cell_height * max_lines)
            
        # Calculate total height needed
        total_height = sum(row_heights) + self.cell_height + 1
        
        # Configure canvas scroll region
        self.table_canvas_db.config(height=total_height)
        
        # Draw headers
        x = 0
        for i, header in enumerate(headers):
            w = col_widths[i] - 1 if i == len(headers)-1 else col_widths[i]
            self.table_canvas_db.create_rectangle(
                x, 0, x + w, self.cell_height, 
                fill=self.header_bg, outline="gray"
            )
            self.table_canvas_db.create_text(
                x + w // 2, self.cell_height // 2, 
                text=header, fill=self.header_fg, 
                font=("Calibri", 10, "bold")
            )
            x += w
        
        # Draw rows
        y = self.cell_height
        for r, row in enumerate(data):
            row_height = row_heights[r]
            bg_color = self.alt_bg if r % 2 == 0 else "white"
            x = 0
            
            for c, cell in enumerate(row):
                w = col_widths[c] - 1 if c == len(row)-1 else col_widths[c]
                self.table_canvas_db.create_rectangle(
                    x, y, x + w, y + row_height, 
                    fill=bg_color, outline="gray"
                )
                
                # Determine text color based on metric
                color = "black"
                
                # Draw multi-line text if needed
                if isinstance(cell , str) and "\n" in cell:
                    lines = cell.split("\n")
                    line_spacing = self.table_font.metrics("linespace") + 2
                    text_block_height = len(lines) * line_spacing
                    y_offset = y + (row_height - text_block_height) / 2
                    for i, line in enumerate(lines):
                        self.table_canvas_db.create_text(
                            x + w // 2, y_offset,
                            anchor="n", text=line,
                            fill=color, font=("Calibri", 10)
                        )
                        y_offset += line_spacing
                else:
                    #Single line
                    self.table_canvas_db.create_text(
                        x + w // 2, y + row_height // 2, 
                        text=cell, fill=color, 
                        font=("Calibri", 10)
                    )
                x += w
            y += row_height
            
    def create_canvas_table_db_cd(self):
        """Create a canvas-based table to display server metrics"""
        # Create container frame
        container_frame = ttkb.Frame(self.content_frame)
        container_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Create scrollable canvas
        self.table_canvas_db_cd = Canvas(container_frame, bg="white", highlightthickness=0)
        self.table_canvas_db_cd.pack(fill="both", expand=True)
        
        # Initialize font
        self.table_font = tkfont.Font(family="Calibri", size=10)
        
        self.table_canvas_db_cd.bind("<Configure>", lambda e: self.draw_table_db_cd())
            
    def get_column_widths_db_cd(self, headers, data, available_width):
        """Calculate column widths based on content"""
        max_text_widths = []
        for col_index in range(len(headers)):
            column_texts = [headers[col_index]] + [str(row[col_index]) for row in data]
            max_width = 0
            for text in column_texts:
                lines = text.split('\n') if isinstance(text, str) else [str(text)]
                line_widths = [self.table_font.measure(line) for line in lines]
                max_width = max(max_width, max(line_widths))
            
            max_text_widths.append(max_width + self.padding)

        total_content_width = sum(max_text_widths)
        
        if total_content_width < available_width:
            # Distribute extra width proportionally
            extra = available_width - total_content_width
            max_text_widths = [w + (extra * w / total_content_width) for w in max_text_widths]
            
        return max_text_widths
    
    def draw_table_db_cd(self):
        """Draw the table with server metrics"""
        if not self.linux_details:
            return
            
        # Prepare headers and data
        headers = [
            "Server", "DB Server Checkdown Status"
        ]
        
        # Combine Windows and Linux data
        data = []
        for server, metrics in self.linux_details.items():
           
            # DB Instance Status
            if metrics['status'] == 'Online' and isinstance(metrics['checkdown'], list):
                checkdown = "\n".join(metrics['checkdown'])
            elif isinstance(metrics['checkdown'], str):
                checkdown = metrics['checkdown']
            else:
                checkdown = "N/A"
                
                
            row = [
                server,
                #metrics['status'],
                #self.server_credentials[server]['type'],
                checkdown
            ]
            data.append(row)
        
        # Clear existing items
        self.table_canvas_db_cd.delete("all")
        
        # Get current canvas width
        canvas_width = self.table_canvas_db_cd.winfo_width()
        if canvas_width < 100:  # Minimum width
            canvas_width = 1000
            
        # Calculate column widths
        col_widths = self.get_column_widths_db_cd(headers, data, canvas_width)
        
        row_heights = []
        for row in data:
            max_lines = 1
            for c, cell in enumerate(row):
                if isinstance(cell, str) and "\n" in cell:
                    line_count = cell.count("\n") + 1
                    if line_count > max_lines:
                        max_lines = line_count
            row_heights.append(self.cell_height * max_lines)
            
        # Calculate total height needed
        total_height = sum(row_heights) + self.cell_height + 1
        
        # Configure canvas scroll region
        self.table_canvas_db_cd.config(height=total_height)
        
        # Draw headers
        x = 0
        for i, header in enumerate(headers):
            w = col_widths[i] - 1 if i == len(headers)-1 else col_widths[i]
            self.table_canvas_db_cd.create_rectangle(
                x, 0, x + w, self.cell_height, 
                fill=self.header_bg, outline="gray"
            )
            self.table_canvas_db_cd.create_text(
                x + w // 2, self.cell_height // 2, 
                text=header, fill=self.header_fg, 
                font=("Calibri", 10, "bold")
            )
            x += w
        
        # Draw rows
        y = self.cell_height
        for r, row in enumerate(data):
            row_height = row_heights[r]
            bg_color = self.alt_bg if r % 2 == 0 else "white"
            x = 0
            
            for c, cell in enumerate(row):
                w = col_widths[c] - 1 if c == len(row)-1 else col_widths[c]
                self.table_canvas_db_cd.create_rectangle(
                    x, y, x + w, y + row_height, 
                    fill=bg_color, outline="gray"
                )
                
                # Determine text color based on metric
                color = "black"
                
                # Draw multi-line text if needed
                if isinstance(cell , str) and "\n" in cell:
                    lines = cell.split("\n")
                    line_spacing = self.table_font.metrics("linespace") + 2
                    for i, line in enumerate(lines):
                        self.table_canvas_db_cd.create_text(
                            x + 5, y + 5 + i * line_spacing,
                            anchor="nw", text=line,
                            fill=color, font=("Calibri", 10)
                        )
                else:
                    #Single line
                    self.table_canvas_db_cd.create_text(
                        x + w // 2, y + row_height // 2, 
                        text=cell, fill=color, 
                        font=("Calibri", 10)
                    )
                x += w
            y += row_height

    def update_plots_with_metrics(self):
        """Update all plots with actual metrics data"""
        # Clear previous plots
        for ax in self.axes:
            ax.clear()
        
        # Update CPU Usage plots
        if self.windows_details:
            # Windows CPU Usage
            windows_servers = list(self.windows_details.keys())
            windows_cpu = [metrics['cpu_usage'] for metrics in self.windows_details.values()]
            cpu_colors = self.get_colors(windows_cpu)
            self.axes[0].bar(windows_servers, windows_cpu, color=cpu_colors, edgecolor='white', linewidth=1)
            self.axes[0].set_title("Windows CPU Usage (%)", fontweight="bold")
            self.axes[0].set_ylim(0, max(windows_cpu) + 10)
            self.axes[0].grid(axis='y', linestyle=':', alpha=0.7)
            for i, val in enumerate(windows_cpu):
                self.axes[0].text(i, val + 2, f"{val}%", ha='center', va="bottom")
        
        if self.linux_details:
            # Linux CPU Usage
            linux_servers = list(self.linux_details.keys())
            linux_cpu = [metrics['cpu_usage'] for metrics in self.linux_details.values()]
            cpu_colors = self.get_colors(linux_cpu)
            self.axes[1].bar(linux_servers, linux_cpu, color=cpu_colors, edgecolor='white', linewidth=1)
            self.axes[1].set_title("Linux CPU Usage (%)", fontweight="bold")
            self.axes[1].set_ylim(0, max(linux_cpu) + 10)
            self.axes[1].grid(axis='y', linestyle=':', alpha=0.7)
            for i, val in enumerate(linux_cpu):
                self.axes[1].text(i, val + 2, f"{val}%", ha='center')
                
        # Update RAM Usage plots
        if self.windows_details:
            # Windows RAM Usage
            windows_servers = list(self.windows_details.keys())
            windows_ram = [metrics['ram_usage'] for metrics in self.windows_details.values()]
            ram_colors = self.get_colors(windows_ram)
            self.axes[2].barh(windows_servers, windows_ram, color=ram_colors, edgecolor='white', linewidth=1)
            self.axes[2].set_title("Windows RAM Usage (%)", fontweight="bold")
            self.axes[2].set_xlim(0, 100)
            self.axes[2].grid(axis='x', linestyle='--', alpha=0.7)
            for i, val in enumerate(windows_ram):
                self.axes[2].text(val + 1, i, f"{val}%", va='center')
        
        if self.linux_details:
            # Linux RAM Usage
            linux_servers = list(self.linux_details.keys())
            linux_ram = [metrics['ram_usage'] for metrics in self.linux_details.values()]
            ram_colors = self.get_colors(linux_ram)
            self.axes[3].barh(linux_servers, linux_ram, color=ram_colors, edgecolor='white', linewidth=1)
            self.axes[3].set_title("Linux RAM Usage (%)", fontweight="bold")
            self.axes[3].set_xlim(0, 100)
            self.axes[3].grid(axis='x', linestyle='--', alpha=0.7)
            for i, val in enumerate(linux_ram):
                self.axes[3].text(val + 1, i, f"{val}%", va='center')
                
        windows_c_drive = [metrics['C_drive'] for metrics in self.windows_details.values()]
        windows_d_drive = [metrics['D_drive'] for metrics in self.windows_details.values()]
        linux_c_drive = [metrics['C_drive'] for metrics in self.linux_details.values()]
                
        self.update_disk_meters(windows_servers, windows_c_drive, windows_d_drive, linux_servers, linux_c_drive)
        
        # Redraw all canvases
        for canvas in self.canvases:
            canvas.draw()
            
    def update_disk_meters(self, windows_servers, windows_c_drive, windows_d_drive, linux_servers, linux_c_drive):
        """Update the disk usage meter widgets with actual data"""
        # Clear existing meters
        for meter in self.c_drive_meters:
            meter.destroy()
        for meter in self.d_drive_meters:
            meter.destroy()
        self.c_drive_meters = []
        self.d_drive_meters = []
        
        '''def print_hei(widget, level=0):
            print("  " * level + f"{widget.winfo_class()} - {widget}")
            for child in widget.winfo_children():
                print_hei(child, level + 1)
        print_hei(self.content_frame)'''
        # Recreate the disk usage plots with updated data
        disk_frame = self.content_frame.winfo_children()[4].winfo_children()[2]
        
        self.create_disk_usage_plots(disk_frame)
        
    def get_colors(self, values):
        """Determine bar colors based on percentage"""
        colors = []
        for val in values:
            if val >= 95:
                colors.append('#f04124')
            elif val >= 85:
                colors.append('#e99002')
            else:
                colors.append('#43ac6a')
        return colors
        
if __name__ == '__main__':
    app = ttkb.Window("Health Check Dashboard", "flatly")
    app.state('zoomed')
    dashboard = SystemHealthCheckDashboard(app)
    app.mainloop()
